#!/bin/bash

# TODO:
# - add previous in navigation
# - add file explorer
# - add logging on stderr
# - add switches for all modes
#       --clear screen in slideshow modes
#       --help
#       --minwidth, --minheight, --maxwidth, --maxheight (in view only with type dir)
#       --auto-max (in view only with type dir)
#       --auto-viewport
#
# - online help in view/manage modes
# - online menu in view/manage modes
#       rate, confirmation, pause, random mode, quiet mode, min/max width/height, auto-max
# - playback control keys
#   next/previous
#   fast forward
#   pause/resume
#   quit
#   rate +/- (for the current file)

shopt -s extglob


# basic info set at init(), not considered configuration
export script_name script_dir script_title script_version sudo


# "somewhat sane" true and false
declare -i FALSE=0
declare -i TRUE=$(( !FALSE ))

declare -A CONFIG
conf() {
    [[ "$1" == unset ]] && {
        unset "CONFIG[$2]"
        return $TRUE
    }

    local k="${1%%=*}" v="${1#*=}"

    if [[ "$1" =~ .+=.+ ]]; then
        case "$v" in
            TRUE|FALSE) (( ${!v} )) && CONFIG[__bool__$k]=${!v}    ;;
            ''|*[!0-9]*) [[ "$v" != '' ]] && CONFIG[__str__$k]="$v"    ;;
                      *) (( v )) && CONFIG[__int__$k]=$v            ;;
        esac
        return $TRUE
    else
        [[ -v CONFIG[__bool__$k] ]] && {
            echo ${CONFIG[__bool__$k]}
            return ${CONFIG[__bool__$k]}
        }

        [[ -v CONFIG[__int__$k] ]] && {
            echo ${CONFIG[__int__$k]}
            return $TRUE
        }

        [[ -v CONFIG[__str__$k] ]] && {
            echo ${CONFIG[__str__$k]}
            return $TRUE
        }
    fi

    return $FALSE
}

clear_stdin() {
    while read -e -t 0.1; do :; done
}

killer() {
    kill $1
}

view_file() {
    (( $(conf quiet) )) || echo -e "\nFile: $1"
    iconv -f 437 -t utf8 "$1" | pv --quiet --rate-limit $(conf rate) &

    # give the user a chance to abort long scrolls
    viewer=$!
    trap "killer $viewer" INT
    while kill -0 "$viewer" &> /dev/null; do :; done
    trap - INT
    trap

    echo -e '\033[0m'
}

view() {
    local -a files
    readarray -t files< <(find "$(conf src)" -iname "*.ans")

    local total=${#files[@]}

    local i r count
    for (( i=0, count=$(( $(conf count) )) ? $(( $(conf count) )) : -1; (i < total) && count; i++, count-- )); do
        if (( $(conf random) )); then
            file="$(readlink -f "${files[$i]}")"
        else
            (( r=RANDOM % ${#files[@]} ))
            file="$(readlink -f "${files[$r]}")"
            unset files[$r]
            files=("${files[@]}")
        fi

        view_file "$file"

        (( count-1 && (i+1 < total) )) && sleep $(( $(conf pause) ))
    done
}

confirm() {
    (( $(conf yes) )) || {
        echo
        read -r -p "${1:-Are you sure? (y/N)} " response
        [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]
    }
}

manage() {
    local base="$(basename "$(readlink -f "$(conf src)")")"
    local file symlink symlink_dir symlink_exists prompt choice

    local -a files
    readarray -t files< <(find "$(conf src)" -iname "*.ans")

    for file in "${files[@]}"; do
        if [[ -n $(conf dst) ]]; then
            file="$(readlink -f "$file")"

            symlink="$base${file##*$base}"
            symlink_dir="$(dirname "$(conf dst)/$symlink")"

            symlink_exists=0
            [[ -L "$(conf dst)/$symlink" ]] && {
                (( $(conf include_linked) )) && continue
                symlink_exists=1
            }
        fi

        # view file loop
        while :; do
            trap '' INT
            view_file "$file"
            trap '' INT

            if [[ -n $(conf dst) ]]; then
                if (( symlink_exists )); then
                    echo "This file is already linked."
                    prompt='unlink/delete/view again/next/quit (l/d/v/n/q)'
                else
                    prompt='link/delete/view again/next/quit (l/d/v/n/q)'
                fi
            else
                prompt='delete/view again/next/quit (d/v/n/q)'
            fi

            clear_stdin

            # ensure-valid-choice loop
            while read -n1 -p "${prompt}? " choice; do
                case "$choice" in
                    d)  confirm || continue 3
                        rm -v "$file"
                        ;&

                    l)  if (( symlink_exists )); then
                            [[ "$choice" == "l" ]] && { confirm || continue 3 ;}

                            rm -v "$(conf dst)/$symlink"

                            while [[ "$symlink_dir" != "$(conf dst)/$base" ]] && [[ -z "$(find "$symlink_dir" -mindepth 1)" ]]; do
                                rmdir -v "$symlink_dir"
                                symlink_dir="$(dirname "$symlink_dir")"
                            done

                        # check we're not cascading from d) before creation
                        elif [[ "$choice" == "l" ]]; then
                            [[ -d "$symlink_dir" ]] || mkdir -vp "$symlink_dir"
                            ln -sv "$file" "$(conf dst)/$symlink"
                        fi

                        continue 3
                        ;;

                    n) continue 3
                        ;;

                    v) continue 2
                        ;;

                    q) echo -e "Bye!\n"
                       return 0
                        ;;

                    *) continue
                        ;;
                esac
            done
        done
    done
}

go() {
    # config defaults
    conf script_name="$0"
    conf script_dir="$(dirname $(readlink -f "$0"))"
    conf script_title="btrfs-backup"
    [[ -f "$(conf script_dir)/VERSION" ]] && conf script_version=$(cat "$script_dir/VERSION")
    conf src=""
    conf dst=""
    conf rate=7000
    conf count=0
    conf pause=0
    conf include_linked=FALSE
    conf yes=FALSE
    conf quiet=FALSE
    conf random=FALSE
    conf automax=FALSE
    conf autovp=FALSE
    conf maxw=0
    conf minw=0
    conf maxh=0
    conf minh=0

    # process command line
    local command=$1; shift

    case $command in
        view)
            conf src="$1"; shift
            ;;

        manage)
            conf src="$1"; shift
            [[ ! "$1" =~ ^--.+ ]] && { conf dst="$1"; shift; }
            ;;
    esac

    while token="$1"; do
        shift
        case "$token" in
            -@(q|-quiet))
                conf quiet=TRUE
                ;;
            -@(t|-rate))
                conf rate=$1
                shift
                ;;
            -@(c|-count))
                conf count=$1
                shift
                ;;
            -@(p|-pause))
                conf pause=$1
                shift
                ;;
            -@(r|-random))
                conf random=TRUE
                ;;
            -@(y|-yes))
                conf yes=TRUE
                ;;
            -@(l|-include-linked))
                conf include_linked=TRUE
                ;;
            -@(w|-minwidth))
                conf min_width=$1
                shift
                ;;
            -@(h|-minheight))
                conf min_height=$1
                shift
                ;;
            -@(W|-maxwidth))
                conf max_width=$1
                shift
                ;;
            -@(H|-maxheight))
                conf max_height=$1
                shift
                ;;
            -@(A|-auto-max))
                conf auto_max=TRUE
                ;;
            -@(V|-auto-viewport))
                conf auto_viewport=TRUE
                ;;
            '') break
                ;;
        esac
    done

    $command
}

go $@
