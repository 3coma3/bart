#!/bin/bash

# TODO:
# - restore rate after watching file
# - improve view loops, and history and previous navigation in random or
#   sequential modes
# - add logging on stderr
# - add --help
# - mini help in viewer (press h)
# - online help in view/manage modes (? option)
# - online menu in view/manage modes (m option)
#       rate, confirmation, pause, random mode, quiet mode, min/max width/height, auto-max
#
# - show detail line in viewer (press l)
#
# - add switches for all modes
#       --minwidth, --minheight, --maxwidth, --maxheight (in view mode, only with type dir)
#       --auto-max (in view mode, only with type dir)
#       --auto-viewport
#
# - add file explorer

shopt -s extglob


# basic info set at init(), not considered configuration
export script_name script_dir script_title script_version sudo


# "somewhat sane" true and false
declare -i FALSE=1
declare -i TRUE=$(( !FALSE ))

declare -A CONFIG
conf() {
    local k v test
    local -i get

    case $1 in
        unset) unset "CONFIG[$2]"
               return $TRUE
               ;;
          get) k="$2" get=$TRUE         ;;
       !(*=*)) k="$1"                   ;;
            *) k="${1%%=*}" v="${1#*=}" ;;
    esac

    if [[ "$1" =~ .+=.+ ]]; then
        case "$v" in
            TRUE|FALSE) (( ${!v} )) && CONFIG[__bool__$k]=${!v}    ;;
            ''|*[!0-9]*) [[ "$v" != '' ]] && CONFIG[__str__$k]="$v"    ;;
                      *) (( v )) && CONFIG[__int__$k]=$v            ;;
        esac
        return $TRUE
    else
        test="__bool__$k"
        [[ -v CONFIG[$test] ]] && {
            [[ -v get ]] && echo ${CONFIG[$test]}
            return ${CONFIG[$test]}
        }

        test="__int__$k"
        [[ -v CONFIG[$test] ]] && {
            [[ -v get ]] && echo ${CONFIG[$test]}
            return $TRUE
        }

        test="__str__$k"
        [[ -v CONFIG[$test] ]] && {
            [[ -v get ]] && echo ${CONFIG[$test]}
            return $TRUE
        }
    fi

    return $FALSE
}

declare -Ai RETCODES=(
    # types
    [TRUE]=$TRUE
    [FALSE]=$FALSE
    [T_UNDEF]=3
    [T_BOOL]=4
    [T_INT]=5
    [T_STR]=6

    # process result
    [P_OK]=0
    [P_NOOP]=0
    [P_ERROR]=1
    [P_ABORT]=11

    # playback control
    [PC_PLAY]=20
    [PC_STOP]=21
    [PC_PAUSE]=22
    [PC_CONT]=23
    [PC_PREV]=24
    [PC_NEXT]=25
    [PC_R_UP]=26
    [PC_R_DOWN]=27
    [PC_R_UP2]=28
    [PC_R_DOWN2]=29
    [PC_MENU]=30
    [PC_HELP]=31
)

retcode() {
    return ${RETCODES[$1]}
}

noop() {
    retcode NOOP
}

log() {
    [[ -v BART_LOG ]] && echo $@ >> "$BART_LOG"
}

view_file() {
    local control playback reader writer pipe=playback_control
    local rf_small=$(conf get rate_factor_small) rf_big=$(conf get rate_factor_big)

    conf quiet || echo -e "\nFile: $1"

    mkfifo $pipe
    iconv -f 437 -t utf8 "$1" > $pipe &
    writer=$!
    pv --quiet -C -B32 --rate-limit $(conf get rate) < $pipe &
    reader=$!

    trap noop INT
    playback=PC_PLAY
    while kill -0 "$reader" &> /dev/null; do
        read -t 0.1 -s -N 1 -d '' control
        clear_stdin
        case $control in
            c) if [[ "$playback" == "PC_PLAY" ]]; then
                    playback=PC_PAUSE
                    pv -R $reader --rate-limit 1
                elif [[ "$playback" == "PC_PAUSE" ]]; then
                    playback=PC_PLAY
                    pv -R $reader --rate-limit $(conf get rate)
                fi

                log "playback $playback"
                ;;
            h) playback=PC_HELP
               log "playback $playback"
               break
               ;;
            m) playback=PC_MENU
               log "playback $playback"
               break
               ;;
            n) playback=PC_NEXT
               log "playback $playback"
               break
               ;;
            p) playback=PC_PREV
               log "playback $playback"
               break
               ;;
            s) playback=PC_STOP
               [[ "$playback" == PC_PLAY ]] && playback=PC_STOP
               log "playback $playback"
               break
               ;;
            u) conf rate=$(( $(conf get rate) + rf_small ))
               pv -R $reader --rate-limit $(conf get rate)
               ;;
            d) conf rate=$(( $(conf get rate) - rf_small < 0 ? 1 : $(conf get rate) - rf_small ))
               pv -R $reader --rate-limit $(conf get rate)
               ;;
            U) conf rate=$(( $(conf get rate) + rf_big ))
               pv -R $reader --rate-limit $(conf get rate)
               ;;
            D) conf rate=$(( $(conf get rate) - rf_big < 0 ? 1 : $(conf get rate) - rf_big ))
               pv -R $reader --rate-limit $(conf get rate)
               ;;
            *) continue
               ;;
        esac
    done

    trap - INT
    kill $writer $reader &> /dev/null
    rm $pipe

    echo -e '\033[0m'
    conf clear && clear
    conf reset && reset
    retcode $playback
}

clear_stdin() {
    read -t 0 && while read -e -t 0.1; do :; done
}

confirm() {
    conf yes || {
        echo
        read -r -p "${1:-Are you sure? (y/N)} " response
        [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]
    }
}

view() {
    local -a files
    readarray -t files< <(find "$(conf get src)" -iname "*.ans")

    local total=${#files[@]}

    local i r count
    for (( i=0, count=$(( $(conf get count) )) ? $(( $(conf get count) )) : -1; (i < total) && count; i++, count-- )); do
        if conf random; then
            file="$(readlink -f "${files[$i]}")"
        else
            (( r=RANDOM % ${#files[@]} ))
            file="$(readlink -f "${files[$r]}")"
            unset files[$r]
            files=("${files[@]}")
        fi

        view_file "$file"
        (( $? == ${RETCODES[PC_STOP]} )) && break

        (( count-1 && (i+1 < total) )) && sleep $(( $(conf get pause) ))
    done
}

manage() {
    local base="$(basename "$(readlink -f "$(conf src)")")"
    local file symlink symlink_dir symlink_exists prompt choice

    local -a files
    readarray -t files< <(find "$(conf get src)" -iname "*.ans")

    for file in "${files[@]}"; do
        if [[ -n $(conf get dst) ]]; then
            file="$(readlink -f "$file")"

            symlink="$base${file##*$base}"
            symlink_dir="$(dirname "$(conf get dst)/$symlink")"

            symlink_exists=0
            [[ -L "$(conf get dst)/$symlink" ]] && {
                conf include_linked && continue
                symlink_exists=1
            }
        fi

        # view file loop
        while :; do
            trap '' INT
            view_file "$file"
            trap '' INT

            if [[ -n $(conf get dst) ]]; then
                if (( symlink_exists )); then
                    echo "This file is already linked."
                    prompt='unlink/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                else
                    prompt='link/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                fi
            else
                prompt='delete/prev/replay/next/quit (d/p/r/n/q)'
            fi

            clear_stdin

            # ensure-valid-choice loop
            while read -n1 -p "${prompt}? " choice; do
                case "$choice" in
                    d) confirm || continue 3
                       rm -v "$file"
                       ;&

                    l) if (( symlink_exists )); then
                           [[ "$choice" == "l" ]] && { confirm || continue 3 ;}
                           rm -v "$(conf get dst)/$symlink"

                           while [[ "$symlink_dir" != "$(conf get dst)/$base" ]] && [[ -z "$(find "$symlink_dir" -mindepth 1)" ]]; do
                               rmdir -v "$symlink_dir"
                               symlink_dir="$(dirname "$symlink_dir")"
                           done
                       # check we're not cascading from d) before creation
                       elif [[ "$choice" == "l" ]]; then
                           [[ -d "$symlink_dir" ]] || mkdir -vp "$symlink_dir"
                           ln -sv "$file" "$(conf get dst)/$symlink"
                       fi

                       continue 3
                       ;;

                    n) continue 3
                       ;;

                    r) continue 2
                       ;;

                    q) echo -e "Bye!\n"
                       return 0
                       ;;

                    *) continue
                       ;;
                esac
            done
        done
    done
}

go() {
    # config defaults
    conf script_name="$0"
    conf script_dir="$(dirname $(readlink -f "$0"))"
    conf script_title="bart"
    [[ -f "$(conf script_dir)/VERSION" ]] && conf script_version=$(cat "$script_dir/VERSION")
    conf src=""
    conf dst=""
    conf rate=5000
    conf rate_factor_small=30
    conf rate_factor_big=150
    conf count=0
    conf pause=0
    conf include_linked=FALSE
    conf yes=FALSE
    conf quiet=FALSE
    conf random=FALSE
    conf automax=FALSE
    conf autovp=FALSE
    conf maxw=0
    conf minw=0
    conf maxh=0
    conf minh=0

    # process command line
    local command=$1; shift

    case $command in
        view)
            conf src="$1"; shift
            ;;

        manage)
            conf src="$1"; shift
            [[ ! "$1" =~ ^--.+ ]] && { conf dst="$1"; shift; }
            ;;
    esac

    while token="$1"; do
        shift
        case "$token" in
            -@(q|-quiet))
                conf quiet=TRUE
                ;;
            -@(t|-rate))
                conf rate=$1
                shift
                ;;
            -@(c|-count))
                conf count=$1
                shift
                ;;
            -@(p|-pause))
                conf pause=$1
                shift
                ;;
            -@(r|-random))
                conf random=TRUE
                ;;
            -@(y|-yes))
                conf yes=TRUE
                ;;
            -@(l|-include-linked))
                conf include_linked=TRUE
                ;;
            -@(c|-clear))
                conf clear=TRUE
                ;;
            -@(s|-reset))
                conf reset=TRUE
                ;;
            -@(w|-minwidth))
                conf min_width=$1
                shift
                ;;
            -@(h|-minheight))
                conf min_height=$1
                shift
                ;;
            -@(W|-maxwidth))
                conf max_width=$1
                shift
                ;;
            -@(H|-maxheight))
                conf max_height=$1
                shift
                ;;
            -@(A|-auto-max))
                conf auto_max=TRUE
                ;;
            -@(V|-auto-viewport))
                conf auto_viewport=TRUE
                ;;
            '') break
                ;;
        esac
    done

    $command
}

go $@
