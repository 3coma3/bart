#!/bin/bash

# TODO:
# ------------------------------------------------------------------------------
# version 1
#
# - WIP
#       manage() is essentially play() with a menu, so it will turned into the
#       menu functionalities, called from play() when MENU is selected
#
#       fix symlink path generation in dst
#       cleanup / simplify management
#       back off from overusing kv in tight loops until it's optimized (and even
#       then, use locals when perf is due)
#
# - features
#       allow entering dst from menu in case it wasn't passed or configured
#       add move operation
#
#       end of list controlled by "loop" flag/playback mode/control
#       add option for flat/preserve structure
#       options for global/per file rate change effects
#       minfilesize maxfilesize
#
#       support for specifying file extensions
#       regex/glob filters, listings and information
#
#       --help or help command
#           complete information under script ns (homepage, etc)
#
#       implemented in native_throttle:
#           PC_REPLAY control
#
# - plumbing
#       use exit and return instead of retcode where it's clearer/better
#       allow FALSE flags from CLI (-no prefix)
#       consider adding cond() (custom ternary, from btrfs-backup)
#       try to have a way to specify / know of logfiles as early as possible, to log
#       initialization before env (ideally right at the start)
#       verbosity levels, complete logging
#       implement kv_t and move types there (should be faster/simpler code, plus it
#       can handle arbitrary attrs like +r, etc)
#
# - UI
#       online menu (press m or have an option to display after each file)
#           operations
#               playback control, move/copy/link/delete source/delete destination, file info, minihelp
#           options
#               rate, confirmation, pause, random mode, quiet mode, min/max width/height, auto-max
#       status line/box (press l or have an option to default it to on/off)
#       auto up/downgrade to text/curses/multiplexers, detecting backends
#
# - pm
#       write initial README
#       auto version (from btrfs_backup)
#
# ------------------------------------------------------------------------------
# version 2
#
# - plumbing
#       modularize and source/call only what's needed
#
# - features
#       --minwidth, --minheight, --maxwidth, --maxheight (in view mode, only with type dir)
#       --auto-max (in view mode, only with type dir)
#       --auto-viewport
#       format exports
#       remote control
#       URL view / browse / crawl / manage
#
# - UI
#       full TUI
#       file explorer
#
# - pm
#       full doc


# BASICS -----------------------------------------------------------------------
shopt -s extglob

# "somewhat sane" true and false
# opposite semantics for return values and arithmetic tests, courtesy of bash
declare -i FALSE=1
declare -i TRUE=$(( !FALSE ))


# VALUE MANAGEMENT -------------------------------------------------------------
declare -A KV
print_arr() {
    local -n arr="$1"
    local v
    for v in ${!arr[@]}; do
        echo $v=${arr[$v]}
    done
}

kv_printns() {
    local filter

    (( $# )) && {
        if [[ $1 =~ .*/.*  ]]; then filter="${1%/*}/(__[^_]+__)*${1##*/}[/=]"
        else filter="(__[^_]+__)*$1[/=]"
        fi
    }

    print_arr KV | sed -rn '\@^'$filter'@p' | sort -u
}

kv_print() {
    local -a TF=( [$TRUE]=TRUE [$FALSE]=FALSE )
    local n t k v

    IFS='|'
    kv_printns $@ | sed -rn 's/^([^_]+)*__([^_]+)__([^=]+)=(.*)$/\1|\2|\3|\4/p' | while read n t k v; do
        echo -n "$n$k="
        case $t in
             str) echo "\"$v\""     ;;
             int) echo $v           ;;
            bool) echo ${TF[$v]}    ;;
        esac
    done
}

kv() {
    local cmd=test line ns k v test

    if [[ $1 =~ ^[^=]+=.*$ ]]; then cmd=set
    elif [[ $1 =~ ^(get|del(ns)*|type|key|print)$ ]]; then cmd=$1; shift
    else cmd=test
    fi

    [[ $cmd == print ]] && {
        kv_print $@
        return $?
    }

    line="$@" ns=${line%%=*}

    # slash at initial or final position, duplicate slash, invalid characters
    local valid_key_chars='a-zA-Z0-9_/'
    [[ "$ns" =~ ^(.*[^$valid_key_chars].*|/.*|[^=/]+/|[^=/]+//.*)(=.*)*$ ]] && {
        error NOKEY "bad namespace/key specification: '$ns'"
    }

    if [[ $ns =~ .*/.*  ]]; then k="${ns##*/}" ns="${ns%/*}"    # normal ns
    else k="$ns" ns=''                                          # root ns (no slashes)
    fi
    ns=${ns:+$ns/}

    case $cmd in
        key)
            v="${line#*=}"
            while read line; do
                [[ "$v" == "${line#*=}" ]] && {
                    echo ${line%%=*} | sed -r 's/(.*\/)__[^_]+__([^\/]+)$/\1\2/'
                    return $TRUE
                }
            done< <(kv_printns $ns$k)
            return $FALSE
            ;;

        set)
            ${FUNCNAME} del "$ns$k" # needed cause type annotations, other solution: keep types in separate hash

            v="${line#*=}"
            case "$v" in
                TRUE|FALSE) KV[${ns}__bool__${k}]=${!v} ;;
                ''|*[!0-9]*) KV[${ns}__str__${k}]="$v"  ;;
                *) KV[${ns}__int__${k}]=$v              ;;
            esac
            return $TRUE
            ;;

        delns)
            while read line; do
                test="${line%%=*}"
                [[ -v KV[$test] ]] && unset KV[$test]
            done< <(kv_printns $ns$k)
            return $TRUE
            ;;
    esac

    for t in bool int str; do
        test="${ns}__${t}__${k}"
        [[ -v KV[$test] ]] && {
            case $cmd in
                get) echo "${KV[$test]}"                      ;;
                del) unset KV[$test]                          ;;
                type) echo $t                                 ;;
                test) [[ $t == bool ]] && return ${KV[$test]} ;;
            esac
            return $TRUE
        }
    done

    return $FALSE
}

kv_load_seq() {
    local ns=$1 base=$2
    shift 2

    while (( $# )); do
        kv $ns/$1=$(( base++ ))
        shift
    done
}


# CODES AND RETURN CODES -------------------------------------------------------
code() {
    local cmd
    [[ $1 =~ ^(get|key|ret)$ ]] && cmd=$1 && shift
    [[ $cmd == ret ]] && return $(kv get codes/$1)
    [[ $cmd == key ]] && {
        kv key codes/$1 | sed -r 's|^codes/||'
        return
    }

    kv $cmd codes/$1
}

noop() {
    code p/NOOP
}


# CONFIG -----------------------------------------------------------------------
pprint_conf() {
    echo -n 'config is: ['
    kv print conf | sed 's/^conf\///' | tr '\n' ',' | sed 's/,$/]/'
}

conf() {
    local cmd

    [[ $1 =~ ^(get|del|type|print)$ ]] && cmd=$1 && shift

    if [[ $cmd == print ]]; then pprint_conf
    else kv $cmd conf/$@
    fi
}


# I/O --------------------------------------------------------------------------
clear_input() {
    while read -e -t 0.1; do :; done
}

user_input() {
    local -A control_mappings=(
        [_]=PP                  # a space
        [h]=HELP
        [m]=MENU
        [n]=NEXT
        [p]=PREV
        [q]=STOP
        [r]=REPLAY
        [u]=R_UP
        [d]=R_DOWN
        [U]=R_UP2
        [D]=R_DOWN2
    )

    local key controls="${!control_mappings[@]}"

    trap noop TTIN

    IFS=''
    while :; do
        read -t0.1 -s -N 1 -d '' key
        key="${key// /_}"
        [[ "$key" =~ [${controls// /}] ]] && {
            echo ${control_mappings[$key]} &
            kill -USR1 $(kv get script/pid)
        }
    done

    trap - TTIN
}

confirm() {
    conf yes || {
        echo
        read -r -p "${1:-Are you sure? (y/N)} " response
        [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]
    }
}

msg() {
    (( $# )) && {
        echo -e "$@" >&2
        return
    }
    cat >&2
}

header() {
    local tmp="${@}" length=80 char='-'
    local header=$(printf "%0$(( length - ${#tmp} ))d")
    msg "\n$@ ${header//?/${char}}\n"
}

error() {
    local code=$1

    if code p/E${code}; then shift
    else code=ERROR
    fi

    (( $# )) && msg "$FUNCNAME: ${FUNCNAME[1]}: $@"
    log "$code $@"

    [[ $code != ERROR ]] && code=E${code}

    exit $(code get p/${code})
}

log() {
    [[ -n "$(conf get logfile)" ]] && echo "${FUNCNAME[1]}: $@" >> "$(conf get logfile)"
}


# MISC UTILS -------------------------------------------------------------------
file_list() {
    find "$(conf get src)" -iname "*.ans" |
        {
            if conf random; then shuf
            else cat
            fi
        }
}

new_tmp () {
    local suffix="$1"
    mktemp -tu $(kv get script/name)-${suffix}.$(printf 'X%.0s' {1..10})
}

new_pipe() {
    local suffix="$1"
    local pipe="$(new_tmp $suffix)"
    mkfifo "$pipe"
    log "created pipe by request of ${FUNCNAME[1]}: $pipe"
    echo "$pipe"
}


# PLAYBACK ---------------------------------------------------------------------
update_throttle() {
    local throttle rate=$(conf get rate | numfmt --from=iec) big=$(conf get rate_factor_big) small=$(conf get rate_factor_small)
    case $1 in
           R_UP) (( rate += small )) ;;
          R_UP2) (( rate += big ))   ;;
         R_DOWN) (( rate -= small )) ;;
        R_DOWN2) (( rate -= big ))   ;;
    esac
    (( rate = rate  < 1 ? 1 : rate ))
    conf rate=$rate

    throttle="$(bc <<< "scale=10; 1 / $(conf get rate | numfmt --from=iec)")"
    kv script/bash_loadables || throttle=$(awk '{printf "%.2e\n", $1}' <<< $throttle)
    kv "pc/throttle=$throttle"

    log "updated rate to $(numfmt --from=iec <<< $rate | numfmt --to=iec)B/s, throttle value is $(kv get pc/throttle)"
}

playback_control() {
    local job_cmd="$1" job input{,_{control,pipe}} interrupt_controls='HELP|MENU'
    shift

    trap noop INT

    conf "stty=$(stty -g)"
    stty -echo
    stty $(stty -g)
    tput civis

    input_pipe=$(new_pipe input)
    exec 4<>"$input_pipe"
    user_input <&0 >&4 & input=$!
    trap "read -rst0.1 -u4 input_control" USR1

    if [[ $(kv get pc/status) =~ ^($interrupt_controls)$ ]]; then
        job=$(kv get pc/job)
        log "resuming $job_cmd $job"
        kill -CONT $job
    else
        kv pc/control_pipe="$(new_pipe control)"
        exec 3<>"$(kv get pc/control_pipe)"

        $job_cmd $@ <&3 >&1 & job=$!
        kv pc/job=$job

        log "started $job_cmd, pid $job"
    fi

    kv pc/status=PLAY

    while kill -0 $job &> /dev/null; do
        [[ -v input_control ]] || continue

        log "got control from input:${input_control}"

        case $input_control in
            PP) if [[ $(kv get pc/status) == PLAY ]]; then
                    kill -STOP $job
                    kv pc/status=PAUSE
                elif [[ $(kv get pc/status) == PAUSE ]]; then
                    kill -CONT $job
                    kv pc/status=PLAY
                fi
                log "playback changed to $(kv get pc/status)"   ;;

            R_@(UP|DOWN)?(2))
                update_throttle $input_control
                kv get pc/throttle >&3 &
                kill -USR1 $job                                 ;;

            @(NEXT|PREV|REPLAY|STOP))
                kill -TERM $job &>/dev/null
                kv pc/status=$input_control
                log "playback changed to $input_control"              ;;

            @($interrupt_controls))
                kill -STOP $job
                log "paused $job_cmd $job"

                kv pc/status=$input_control
                log "playback changed to $input_control"
                break                                           ;;

            *) :                                                ;;
        esac

        unset input_control
    done

    kill $input &>/dev/null
    exec 4>&-
    log $(rm -v "$input_pipe")

    stty "$(conf get stty)"
    echo -e '\033[0;10m'
    tput cnorm

    # Preserve playback state to resume after interrupting controls
    [[ $(kv get pc/status) =~ ^($interrupt_controls)$ ]] && return

    exec 3>&-
    log $(rm -v "$(kv get pc/control_pipe)")
    kv del pc/control_pipe
    kv del pc/job

    log "finished $job_cmd $job"

    trap - INT
}

viewer() {
    local file="${1:-$(conf get src)}" throttle=$(kv get pc/throttle) control IFS=

    trap noop TTIN TTOU HUP

    kv script/bash_loadables && {
        export BASH_LOADABLES_PATH="$(kv get script/bash_loadables)"
        enable -f sleep sleep
    }

    local -a contents
    mapfile contents< <(iconv -f IBM437 -t utf8 "$file")

    log "viewing file: $file"
    conf quiet || msg "\nFile: $file"

    trap "read -rst0.1 control" USR1
    for line in "${contents[@]}"; do
        for (( i = 0; i < ${#line}; i++ )); do
            echo -ne ${line:i:1}
            [[ -v control ]] && {
                log "got throttle value $control in viewer"
                throttle=$control
                unset control
            }
            sleep $throttle
        done
    done

    trap - USR1 TTIN TTOU HUP

    log "end view"
}

pauser() {
    log "pausing $(conf get pause) seconds"

    trap noop USR1 HUP
    sleep $(conf get pause)
    trap - USR1 HUP

    log "end pause"
}

input_controlled() {
    job=$1
    playback_control ${@}
    log "playback status from $job: $(kv get pc/status)"
}

cursor_to_end() {
    local cursor=$(kv get pc/cursor) to_{count,total,end}
    (( to_count = $(conf get count) - cursor, to_total = $(kv get pc/total) - cursor,
       to_end = to_count < to_total ? to_count : to_total ))
    [[ $@ =~ --log ]] && log "playlist cursor $cursor, to count: $to_count, to total: $to_total, to end: $to_end"
    [[ $@ =~ --echo ]] && echo $(( to_end ))
    (( to_end ))
}


# COMMANDS ---------------------------------------------------------------------
cmd_view() {
    local -a playlist cursor total job
    readarray -t playlist< <(file_list)

    total=${#playlist[@]}
    kv pc/total=$total
    (( $(conf get count) )) || conf count=$total

    log "playing $(conf get count) images (max $total) from $(conf get src)"

    update_throttle

    kv pc/status=PLAY
    kv pc/cursor=0

    for (( cursor=$(kv get pc/cursor); ++cursor, $(cursor_to_end --echo --log); )); do
        kv pc/cursor=$cursor

        input_controlled viewer "$(readlink -f "${playlist[$cursor]}")"

        (( $(conf get pause) )) && [[ $(kv get pc/status) == PLAY ]] && cursor_to_end &&
            input_controlled pauser

        case $(kv get pc/status) in
            @(HELP|MENU)) s=$(kv get pc/status)
                          log "here we should we calling ${s,,}()"
                          sleep 5

                          (( cursor-- ))        # freeze cursor
                          continue              ;;

                  REPLAY) kv pc/status=PC_PLAY
                          (( cursor-- ))        # freeze cursor
                          continue              ;;

                    PREV) (( cursor -= (cursor ? 2 : 1) ))  # rewind cursor
                          continue              ;;

                    STOP) break                 ;;
        esac

        conf clear && clear
        conf reset && reset
    done

    kv pc/status=STOP
    log "end playback"
}

cmd_manage() {
    local base="$(basename "$(readlink -f "$(conf get src)")")"
    local file symlink symlink_dir symlink_exists prompt choice

    local -a files
    readarray -t files< <(file_list)
    local total=${#files[@]}

    (( $(conf get count) )) || conf count=$total

    local i
    for (( i = 0; i < $(conf get count) && i < total; i++ )); do
        log "list pointer $i"

        trap noop INT
        file="$(readlink -f "${files[$i]}")"

        if [[ -n $(conf get dst) ]]; then
            symlink="$base${file##*$base}"
            symlink_dir="$(dirname "$(conf get dst)/$symlink")"

            symlink_exists=0
            [[ -L "$(conf get dst)/$symlink" ]] && {
                conf include_linked && continue
                symlink_exists=1
            }
        fi

        # view file loop
        while :; do
            view_file "$file"
            clear_stdin

            if [[ -z $(conf get dst) ]]; then prompt='delete/prev/replay/next/quit (d/p/r/n/q)'
            else
                if (( symlink_exists )); then
                    msg "This file is already linked."
                    prompt='unlink/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                else
                    prompt='link/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                fi
            fi

            # ensure-valid-choice loop
            while read -n1 -p "${prompt}? " choice; do
                case "$choice" in
                    d) confirm || continue 3
                       rm -v "$file"                    ;&

                    l) if (( symlink_exists )); then
                           [[ "$choice" == l ]] && { confirm || continue 3 ;}
                           rm -v "$(conf get dst)/$symlink"

                           while [[ "$symlink_dir" != "$(conf get dst)/$base" ]] && [[ -z "$(find "$symlink_dir" -mindepth 1)" ]]; do
                               rmdir -v "$symlink_dir"
                               symlink_dir="$(dirname "$symlink_dir")"
                           done
                       # check we're not cascading from d) before creation
                       elif [[ "$choice" == l ]]; then
                           [[ -d "$symlink_dir" ]] || mkdir -vp "$symlink_dir"
                           ln -sv "$file" "$(conf get dst)/$symlink"
                       fi

                       continue 3                       ;;

                    p) (( i -= (i ? 2 : 1) ))
                       continue 3                       ;;
                    n) continue 3                       ;;
                    r) continue 2                       ;;
                    q) echo -e "Bye!\n"
                       return $(code get p/SUCCESS)     ;;
                esac
            done
        done

        trap - INT
    done
}

cmd_config() {
    kv print conf | sed -r 's|^conf/||'
}


# INITIALIZATION ---------------------------------------------------------------
init_codes() {
    # types
    kv codes/t/TRUE=TRUE
    kv codes/t/FALSE=FALSE
    kv_load_seq codes/t 2 UNDEF BOOL INT STR ENOKEY

    # process status
    kv codes/p/SUCCESS=TRUE
    kv codes/p/ERROR=FALSE
    kv_load_seq codes/p 10 NOOP ABORT ENO{CMD,TOK}

    code p/SUCCESS
}

init_script() {
    kv script/pid=$$
    kv script/name="$(basename "$0")"
    kv script/dir="$(dirname $(readlink -f "$0"))"
    [[ -f "$(kv get script/dir)/VERSION" ]] && kv script/version=$(cat "$(kv get script/dir)/VERSION")
    kv script/title=bart
    kv script/env_prefix=$(kv get script/title | sed -r 's/./\U&/g')

    code p/SUCCESS
}

init_config() {
    log "$(kv get script/title) $(kv get script/version) initializing config"

    # config priority: defaults < config < env < cli
    conf config=''
    conf logfile=''
    conf src=''
    conf dst=''
    conf rate='1K'
    conf rate_factor_small=16
    conf rate_factor_big=256
    conf count=0
    conf pause=0
    conf include_linked=FALSE
    conf yes=FALSE
    conf quiet=FALSE
    conf random=FALSE
    conf automax=FALSE
    conf autovp=FALSE
    conf maxw=0
    conf minw=0
    conf maxh=0
    conf minh=0

    local k kenv
    while read k; do
        k="${k%=*}" k="${k##*/}" kenv=$(kv get script/env_prefix)_${k^^}
        [[ -v $kenv ]] && {
            echo "got option from environment: $k=${!kenv}" >> log
            conf $k=${!kenv}
        }
    done< <(kv print conf)
    log 'done processing defaults and env'
    log "$(conf print)"

    [[ -f "$(conf get config)" ]] && {
        log "processing config file: $(conf get config)"
        while read line; do
            [[ $line =~ ^script_.* ]] && continue
            k=$(conf get script_env_prefix)_${line%%=*}
            [[ ! -v "${k^^}" ]] && {
                log "got option from config file: $line"
                conf "$line"
            }
        done< <(cat "$(conf get config)")

        log 'done processing config file'
        log "$(conf print)"
    }

    (( $# )) && {
        log "processing CLI: $@"

        # cli
        local command=$1
        [[ $(type -t cmd_$command) == function ]] || error NOCMD "unrecognized command $command"

        log "CLI got command: $command"
        kv script/command=$command

        shift

        local token k skip=FALSE src_cli=FALSE dst_cli=FALSE
        while :; do
            code t/${skip} || {
                token="$1"
                shift
            }
            skip=FALSE

            case "$token" in
                -@(l*|-include-linked)) k='include_linked=TRUE' ;;
                        -@(r*|-random)) k='random=TRUE'         ;;
                         -@(c*|-clear)) k='clear=TRUE'          ;;
                         -@(R*|-reset)) k='reset=TRUE'          ;;
                         -@(q*|-quiet)) k='quiet=TRUE'          ;;
                           -@(y*|-yes)) k='yes=TRUE'            ;;
                      -@(A*|-auto-max)) k='auto_max=TRUE'       ;;
                 -@(V*|-auto-viewport)) k='auto_viewport=TRUE'  ;;
                         -@(n|-count)*) k=count                 ;;
                          -@(t|-rate)*) k=rate                  ;;
                         -@(p|-pause)*) k=pause                 ;;
                      -@(w|-minwidth)*) k=min_width             ;;
                      -@(W|-maxwidth)*) k=max_width             ;;
                     -@(h|-minheight)*) k=min_height            ;;
                     -@(H|-maxheight)*) k=max_height            ;;
                       -@(L|-logfile)*) k=logfile               ;;
                                 !(-*)) if ! code t_${src_cli}; then
                                            log "CLI got src: $token"
                                            src_cli=TRUE
                                            conf src="$token"
                                            k=src
                                        elif ! code t_${dst_cli}; then
                                            log "CLI got dst: $token"
                                            dst_cli=TRUE
                                            conf dst="$token"
                                            k=dst
                                        fi                      ;;
            esac

            [[ -v k ]] || error NOTOK "unrecognized token $token"

            if [[ $k =~ ^[^=]+=(TRUE|FALSE)$ ]]; then
                log "CLI got flag: $k"
                conf "$k"

                [[ $token =~ ^-[[:alpha:]][^-]+$ ]] && {
                    token="-${token:2}"
                    log "CLI has more short options to try: $token"
                    skip=TRUE
                }
            elif [[ $token =~ ^-[[:alpha:]][[:alnum:]]+$ ]]; then
                log "CLI got short option: $token ($k=${token:2})"
                conf "$k=${token:2}"
            elif [[ $token =~ ^-{1,2}[[:alnum:]]+$ ]]; then
                log "CLI got option with space: $token ($k=$1)"
                conf "$k=$1"
                shift
            elif [[ $token =~ ^-{1,2}[[:alnum:]]+(=.+)$ ]]; then
                log "CLI got option with equal: $token ($k=${token##*=})"
                conf "$k=${token##*=}"
            fi

            unset k
            code t/${skip} || (( $# )) || break
        done

        log 'done processing CLI'
        log "$(conf print)"
    }

    log 'done processing configuration'

    code p/SUCCESS
}

init_misc() {
    conf tty=$(tty)

    local bash_loadables="$(pkg-config bash --variable=loadablesdir &2> /dev/null )"
    [[ -n "$bash_loadables" ]] && kv script/bash_loadables="$bash_loadables"

    code p/SUCCESS
}

init() {
    local f initqueue

    while (( $# )); do
        f=init_${1}
        [[ $(type -t $f) != function || "$initqueue" =~ (^| )"$f"( |$) ]] && break
        initqueue="$initqueue $f"
        shift
    done

    for f in $initqueue; do
       $f $@ || return $?
    done
}


# PROGRAM ----------------------------------------------------------------------
init codes script config misc $@ && cmd_$(kv get script/command)
