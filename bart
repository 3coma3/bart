#!/bin/bash

# TODO:
# ------------------------------------------------------------------------------
# - use playback_control() in foreground
# - preload entire file in memory, use optional double buffer
# - use coproc to receive messages from subshell


# BASICS -----------------------------------------------------------------------
shopt -s extglob

# "somewhat sane" true and false
# opposite semantics for return values and arithmetic tests, courtesy of bash
declare -i FALSE=1
declare -i TRUE=$(( !FALSE ))


# VALUE MANAGEMENT -------------------------------------------------------------
declare -A KV

print_arr() {
    local -n arr="$1"
    local v
    for v in ${!arr[@]}; do
        echo $v=${arr[$v]}
    done
}

kv_printns() {
    local filter

    (( $# )) && {
        if [[ $1 =~ .*/.*  ]]; then filter="${1%/*}/(__[^_]+__)*${1##*/}[/=]"
        else filter="(__[^_]+__)*$1[/=]"
        fi
    }

    print_arr KV | sed -rn '\@^'$filter'@p' | sort -u
}

kv_print() {
    local -a TF=( [$TRUE]=TRUE [$FALSE]=FALSE )
    local n t k v

    IFS='|'
    kv_printns $@ | sed -rn 's/^([^_]+)*__([^_]+)__([^=]+)=(.*)$/\1|\2|\3|\4/p' | while read n t k v; do
        echo -n "$n$k="
        case $t in
             str) echo "\"$v\""     ;;
             int) echo $v           ;;
            bool) echo ${TF[$v]}    ;;
        esac
    done
}

kv() {
    local cmd=test line ns k v test

    if [[ $1 =~ ^[^=]+=.*$ ]]; then cmd=set
    elif [[ $1 =~ ^(get|del(ns)*|type|key|print)$ ]]; then cmd=$1; shift
    else cmd=test
    fi

    [[ $cmd == print ]] && {
        kv_print $@
        return $?
    }

    line="$@" ns=${line%%=*}

    # slash at initial or final position, duplicate slash, invalid characters
    local valid_key_chars='a-zA-Z0-9_/'
    [[ "$ns" =~ ^(.*[^$valid_key_chars].*|/.*|[^=/]+/|[^=/]+//.*)(=.*)*$ ]] && {
        error NOKEY "bad namespace/key specification: '$ns'"
    }

    if [[ $ns =~ .*/.*  ]]; then k="${ns##*/}" ns="${ns%/*}"    # normal ns
    else k="$ns" ns=''                                          # root ns (no slashes)
    fi
    ns=${ns:+$ns/}

    [[ $cmd == key ]] && {
        v="${line#*=}"
        while read line; do
            [[ "$v" == "${line#*=}" ]] && {
                echo ${line%%=*} | sed -r 's/(.*\/)__[^_]+__([^\/]+)$/\1\2/'
                return $TRUE
            }
        done< <(kv_printns $ns$k)
        return $FALSE
    }

    [[ $cmd == set ]] && {
        ${FUNCNAME} del "$ns$k" # needed cause type annotations, other solution: keep types in separate hash

        v="${line#*=}"
        case "$v" in
             TRUE|FALSE) KV[${ns}__bool__${k}]=${!v} ;;
            ''|*[!0-9]*) KV[${ns}__str__${k}]="$v"   ;;
                      *) KV[${ns}__int__${k}]=$v     ;;
        esac
        return $TRUE
    }

    [[ $cmd == delns ]] && {
        while read line; do
            test="${line%%=*}"
            [[ -v KV[$test] ]] && unset KV[$test]
        done< <(kv_printns $ns$k)
        return $TRUE
    }

    for t in bool int str; do
        test="${ns}__${t}__${k}"
        [[ -v KV[$test] ]] && {
            case $cmd in
                get) echo "${KV[$test]}"                      ;;
                del) unset KV[$test]                          ;;
                type) echo $t                                 ;;
                test) [[ $t == bool ]] && return ${KV[$test]} ;;
            esac
            return $TRUE
        }
    done

    return $FALSE
}

kv_load_seq() {
    local ns=$1 base=$2
    shift 2

    while (( $# )); do
        kv $ns/$1=$(( base++ ))
        shift
    done
}


# CODES AND RETURN CODES -------------------------------------------------------
code() {
    local cmd
    [[ $1 =~ ^(get|key|ret)$ ]] && cmd=$1 && shift
    [[ $cmd == ret ]] && return $(kv get codes/$1)
    [[ $cmd == key ]] && {
        kv key codes/$1 | sed -r 's|^codes/||'
        return
    }

    kv $cmd codes/$1
}

noop() {
    code p/NOOP
}


# CONFIG -----------------------------------------------------------------------
pprint_conf() {
    echo -n 'config is: ['
    kv print conf | sed 's/^conf\///' | tr '\n' ',' | sed 's/,$/]/'
}

conf() {
    local cmd

    [[ $1 =~ ^(get|del|type|print)$ ]] && cmd=$1 && shift

    if [[ $cmd == print ]]; then pprint_conf
    else kv $cmd conf/$@
    fi
}


# I/O --------------------------------------------------------------------------
clear_stdin() {
    read -t 0 && while read -e -t 0.1 < $(conf get tty) ; do :; done
}
confirm() {
    conf yes || {
        echo
        read -r -p "${1:-Are you sure? (y/N)} " response
        [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]
    }
}

msg() {
    (( $# )) && {
        echo -e "$@" >&2
        return
    }
    cat >&2
}

header() {
    local tmp="${@}" length=80 char='-'
    local header=$(printf "%0$(( length - ${#tmp} ))d")
    msg "\n$@ ${header//?/${char}}\n"
}

error() {
    local code=$1

    if code p/E${code}; then shift
    else code=ERROR
    fi

    (( $# )) && msg "$FUNCNAME: ${FUNCNAME[1]}: $@"
    log "$code $@"

    [[ $code != ERROR ]] && code=E${code}

    exit $(code get p/${code})
}

log() {
    [[ -n "$(conf get logfile)" ]] && echo "${FUNCNAME[1]}: $@" >> "$(conf get logfile)"
}


# MISC UTILS -------------------------------------------------------------------
file_list() {
    find "$(conf get src)" -iname "*.ans" |
        {
            if conf random; then shuf
            else cat
            fi
        }
}

new_tmp () {
    local suffix="${1}"
    mktemp -tu $(conf get script_name)${suffix}.$(printf 'X%.0s' {1..10})
}

new_pipe() {
    local pipe="$(new_tmp playback)"
    mkfifo "$pipe"
    log "created pipe by request of ${FUNCNAME[1]}: $pipe"
    echo "$pipe"
}


# PLAYBACK ---------------------------------------------------------------------
playback_control() {
    local -A control_mappings=(
        [_]=PP      # this is a space
        [h]=HELP
        [m]=MENU
        [n]=NEXT
        [p]=PREV
        [q]=STOP
        [u]=R_UP
        [d]=R_DOWN
        [U]=R_UP2
        [D]=R_DOWN2
    )

    local key controls="${!control_mappings[@]}"

    IFS=''
    while :; do
        read -t 0.1 -s -N 1 -d '' key < $(conf get tty)
        #clear_stdin

        key="${key// /_}"
        if [[ $key =~ [${controls// /}] ]]; then echo ${control_mappings[$key]}
        else echo NOOP
        fi
    done
}

update_throttle() {
    local rate=$(conf get rate | numfmt --from=iec) big=$(conf get rate_factor_big) small=$(conf get rate_factor_small)
    case $1 in
           R_UP) (( rate += small )) ;;
          R_UP2) (( rate += big ))   ;;
         R_DOWN) (( rate -= small )) ;;
        R_DOWN2) (( rate -= big ))   ;;
    esac
    (( rate = rate  < 1 ? 1 : rate ))
    conf rate=$rate
    #conf "throttle=$(bc <<< "scale=10; 1 / $(conf get rate | numfmt --from=iec)" | awk '{printf "%.2e\n", $1}')"
    conf "throttle=$(bc <<< "scale=10; 1 / $(conf get rate | numfmt --from=iec)")"
    log "updated rate to $(numfmt --from=iec <<< $rate | numfmt --to=iec)B/s, throttle value is $(conf get throttle)"
}

throttle() {
    sleep ${1:-$(conf get throttle)}
}

# COMMANDS ---------------------------------------------------------------------
view_loop() {
    local file="${1:-$(conf get src)}" control viewer viewer_pipe=$(new_pipe)

    conf quiet || msg "\nFile: $file"
    log "viewing file: $file"

    kv pc/status=PLAY

    conf "stty=$(stty -g)"
    tput civis

    trap noop INT

    {   local IFS= t=$(conf get throttle) control
        trap "read -rst0.1 control < $viewer_pipe" USR1
        while read -sra line; do
            for (( i = 0; i < ${#line}; i++ )); do
                echo -ne ${line:i:1}
                [[ -v control ]] && {
                    log "got throttle control $control in viewer"
                    update_throttle $control
                    unset control
                    t=$(conf get throttle)
                }
                throttle $t
            done
            echo
        done< <(iconv -f IBM437 -t utf8 "$file")
        trap - USR1
    }& viewer=$!

    while kill -0 "$viewer" &> /dev/null; do
        unset control
        read -t0.5 control
        [[ $control != NOOP ]] && log "got playback control $control"

        case $control in
            PP) if [[ $(kv get pc/status) == PLAY ]]; then
                    kv pc/status=PAUSE
                    kill -STOP $viewer
                elif [[ $(kv get pc/status) == PAUSE ]]; then
                    kv pc/status=PLAY
                    kill -CONT $viewer
                fi
                log "playback changed to $(kv get pc/status)"   ;;
            R_@(UP|DOWN)?(2))
                update_throttle $control
                { echo $control >> "$viewer_pipe" ;}&
                kill -USR1 $viewer                              ;;
            @(NEXT|PREV|HELP|MENU|REPLAY))
                kv pc/status=$control
                log "playback changed to $(kv get pc/status)"
                break                                           ;;
            STOP)
                [[ $(kv get pc/status) == PLAY ]] && {
                    kv pc/status=STOP
                    log "playback changed to $(kv get pc/status)"
                }
                break                                           ;;
            *) continue                                         ;;
        esac
    done< <(playback_control)

    trap - INT USR1
    kill $viewer &> /dev/null
    log $(rm -v "$viewer_pipe")

    stty "$(conf get stty)"
    #tput sgr0
    echo -e '\033[0m'
    tput cnorm

    log "end view"
}

pause_loop() {
    local control sleeper

    log "pausing $(conf get pause) seconds"

    sleep $(( $(conf get pause) )) & sleeper=$!

    while kill -0 $sleeper &> /dev/null; do
        unset control
        read -t0.5 control
        [[ ! $control == NOOP ]] && log "got playback control $control"

        case $control in
            PP) if [[ $(kv get pc/status) == PLAY ]]; then kv pc/status=PAUSE
                elif [[ $(kv get pc/status) == PAUSE ]]; then kv pc/status=PLAY
                fi
                log "playback changed to $(kv get pc/status)"
                break                                           ;;
            R_@(UP|DOWN)?(2))
                update_throttle $control                        ;;
            @(NEXT|PREV|REPLAY|HELP|MENU))
                kv pc/status=$control
                log "playback changed to $(kv get pc/status)"
                break                                           ;;
            STOP)
                [[ $(kv get pc/status) == PLAY ]] && {
                    kv pc/status=STOP
                    log "playback changed to $(kv get pc/status)"
                }
                break                                           ;;
            *) continue                                         ;;
        esac
    done< <(playback_control)

    log "end pause"
}

at_end() {
    local cursor=$1 total=$2 to_count to_total
    echo $(( to_count=$(conf get count) - cursor, to_total=total - cursor ))
    log "cursor $cursor, to count: $to_count, to total: $to_total"
    (( to_count < 2 || to_total < 2 ))
}


# COMMANDS ---------------------------------------------------------------------
cmd_view() {
    local -a playlist
    readarray -t playlist< <(file_list)
    local total=${#playlist[@]}

    (( $(conf get count) )) || conf count=$total

    log "playing $(conf get count) images (max $total) from $(conf get src)"

    kv pc/status=PLAY

    local cursor
    for (( cursor = 0; cursor < $(conf get count) && cursor < total; cursor++ )); do
        log "playlist cursor: $cursor"

        [[ $(kv get pc/status) =~ ^((RE)?PLAY|NEXT|PREV)$ ]] && view_loop "$(readlink -f "${playlist[$cursor]}")"
        log "playback is $(kv get pc/status)"

        # last file skips pause, as well as status other than play/pause
        (( $(conf get pause) )) && ! at_end $cursor $total &&
        [[ $(kv get pc/status) =~ ^(PLAY|PAUSE)$ ]] && pause_loop
        log "playback is $(kv get pc/status)"

        case $(kv get pc/status) in
            REPLAY) playback=PC_PLAY                ;&
            PAUSE) (( cursor-- )) ; continue        ;; # freeze cursor
            PREV) (( cursor -= (cursor ? 2 : 1) ))  ;; # move cursor
            STOP)                                   ;&
            @(HELP|MENU)) break                     ;; # not yet implemented, get out
        esac

        conf clear && clear
        conf reset && reset
    done

    kv pc/status=STOP
    log "end playback"
}

cmd_manage() {
    local base="$(basename "$(readlink -f "$(conf get src)")")"
    local file symlink symlink_dir symlink_exists prompt choice

    local -a files
    readarray -t files< <(file_list)
    local total=${#files[@]}

    (( $(conf get count) )) || conf count=$total

    local i
    for (( i = 0; i < $(conf get count) && i < total; i++ )); do
        log "list pointer $i"

        trap noop INT
        file="$(readlink -f "${files[$i]}")"

        if [[ -n $(conf get dst) ]]; then
            symlink="$base${file##*$base}"
            symlink_dir="$(dirname "$(conf get dst)/$symlink")"

            symlink_exists=0
            [[ -L "$(conf get dst)/$symlink" ]] && {
                conf include_linked && continue
                symlink_exists=1
            }
        fi

        # view file loop
        while :; do
            view_file "$file"
            clear_stdin

            if [[ -z $(conf get dst) ]]; then prompt='delete/prev/replay/next/quit (d/p/r/n/q)'
            else
                if (( symlink_exists )); then
                    msg "This file is already linked."
                    prompt='unlink/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                else
                    prompt='link/delete/prev/replay/next/quit (l/d/p/r/n/q)'
                fi
            fi

            # ensure-valid-choice loop
            while read -n1 -p "${prompt}? " choice; do
                case "$choice" in
                    d) confirm || continue 3
                       rm -v "$file"                    ;&

                    l) if (( symlink_exists )); then
                           [[ "$choice" == l ]] && { confirm || continue 3 ;}
                           rm -v "$(conf get dst)/$symlink"

                           while [[ "$symlink_dir" != "$(conf get dst)/$base" ]] && [[ -z "$(find "$symlink_dir" -mindepth 1)" ]]; do
                               rmdir -v "$symlink_dir"
                               symlink_dir="$(dirname "$symlink_dir")"
                           done
                       # check we're not cascading from d) before creation
                       elif [[ "$choice" == l ]]; then
                           [[ -d "$symlink_dir" ]] || mkdir -vp "$symlink_dir"
                           ln -sv "$file" "$(conf get dst)/$symlink"
                       fi

                       continue 3                       ;;

                    p) (( i -= (i ? 2 : 1) ))
                       continue 3                       ;;
                    n) continue 3                       ;;
                    r) continue 2                       ;;
                    q) echo -e "Bye!\n"
                       return $(code get p/SUCCESS)     ;;
                esac
            done
        done

        trap - INT
    done
}

cmd_config() {
    kv print conf | sed -r 's|^conf/||'
}


# INITIALIZATION ---------------------------------------------------------------
init_codes() {
    # types
    kv codes/t/TRUE=TRUE
    kv codes/t/FALSE=FALSE
    kv_load_seq codes/t 2 UNDEF BOOL INT STR ENOKEY

    # process status
    kv codes/p/SUCCESS=TRUE
    kv codes/p/ERROR=FALSE
    kv_load_seq codes/p 10 NOOP ABORT ENO{CMD,TOK}

    code p/SUCCESS
}

init_script() {
    kv script/pid=$$
    kv script/name="$(basename "$0")"
    kv script/dir="$(dirname $(readlink -f "$0"))"
    [[ -f "$(kv get script/dir)/VERSION" ]] && kv script/version=$(cat "$(kv get script/dir)/VERSION")
    kv script/title=bart
    kv script/env_prefix=$(kv get script/title | sed -r 's/./\U&/g')

    code p/SUCCESS
}

init_config() {
    log "$(kv get script/title) $(kv get script/version) initializing config"

    # config priority: defaults < config < env < cli
    conf config=''
    conf logfile=''
    conf src=''
    conf dst=''
    conf rate='1K'
    conf rate_factor_small=16
    conf rate_factor_big=256
    conf count=0
    conf pause=0
    conf include_linked=FALSE
    conf yes=FALSE
    conf quiet=FALSE
    conf random=FALSE
    conf automax=FALSE
    conf autovp=FALSE
    conf maxw=0
    conf minw=0
    conf maxh=0
    conf minh=0

    local k kenv
    while read k; do
        k="${k%=*}" k="${k##*/}" kenv=$(kv get script/env_prefix)_${k^^}
        [[ -v $kenv ]] && {
            echo "got option from environment: $k=${!kenv}" >> log
            conf $k=${!kenv}
        }
    done< <(kv print conf)
    log 'done processing defaults and env'
    log "$(conf print)"

    [[ -f "$(conf get config)" ]] && {
        log "processing config file: $(conf get config)"
        while read line; do
            [[ $line =~ ^script_.* ]] && continue
            k=$(conf get script_env_prefix)_${line%%=*}
            [[ ! -v "${k^^}" ]] && {
                log "got option from config file: $line"
                conf "$line"
            }
        done< <(cat "$(conf get config)")

        log 'done processing config file'
        log "$(conf print)"
    }

    (( $# )) && {
        log "processing CLI: $@"

        # cli
        local command=$1
        [[ $(type -t cmd_$command) == function ]] || error NOCMD "unrecognized command $command"

        log "CLI got command: $command"
        kv script/command=$command

        shift

        local token k skip=FALSE src_cli=FALSE dst_cli=FALSE
        while :; do
            code t/${skip} || {
                token="$1"
                shift
            }
            skip=FALSE

            case "$token" in
                -@(l*|-include-linked)) k='include_linked=TRUE' ;;
                        -@(r*|-random)) k='random=TRUE'         ;;
                         -@(c*|-clear)) k='clear=TRUE'          ;;
                         -@(R*|-reset)) k='reset=TRUE'          ;;
                         -@(q*|-quiet)) k='quiet=TRUE'          ;;
                           -@(y*|-yes)) k='yes=TRUE'            ;;
                      -@(A*|-auto-max)) k='auto_max=TRUE'       ;;
                 -@(V*|-auto-viewport)) k='auto_viewport=TRUE'  ;;
                         -@(n|-count)*) k=count                 ;;
                          -@(t|-rate)*) k=rate                  ;;
                         -@(p|-pause)*) k=pause                 ;;
                      -@(w|-minwidth)*) k=min_width             ;;
                      -@(W|-maxwidth)*) k=max_width             ;;
                     -@(h|-minheight)*) k=min_height            ;;
                     -@(H|-maxheight)*) k=max_height            ;;
                       -@(L|-logfile)*) k=logfile               ;;
                                 !(-*)) if ! code t_${src_cli}; then
                                            log "CLI got src: $token"
                                            src_cli=TRUE
                                            conf src="$token"
                                            k=src
                                        elif ! code t_${dst_cli}; then
                                            log "CLI got dst: $token"
                                            dst_cli=TRUE
                                            conf dst="$token"
                                            k=dst
                                        fi                      ;;
            esac

            [[ -v k ]] || error NOTOK "unrecognized token $token"

            if [[ $k =~ ^[^=]+=(TRUE|FALSE)$ ]]; then
                log "CLI got flag: $k"
                conf "$k"

                [[ $token =~ ^-[[:alpha:]][^-]+$ ]] && {
                    token="-${token:2}"
                    log "CLI has more short options to try: $token"
                    skip=TRUE
                }
            elif [[ $token =~ ^-[[:alpha:]][[:alnum:]]+$ ]]; then
                log "CLI got short option: $token ($k=${token:2})"
                conf "$k=${token:2}"
            elif [[ $token =~ ^-{1,2}[[:alnum:]]+$ ]]; then
                log "CLI got option with space: $token ($k=$1)"
                conf "$k=$1"
                shift
            elif [[ $token =~ ^-{1,2}[[:alnum:]]+(=.+)$ ]]; then
                log "CLI got option with equal: $token ($k=${token##*=})"
                conf "$k=${token##*=}"
            fi

            unset k
            code t/${skip} || (( $# )) || break
        done

        log 'done processing CLI'
        log "$(conf print)"
    }

    log 'done processing configuration'

    code p/SUCCESS
}

init_misc() {
    update_throttle
    conf tty=$(tty)

    code p/SUCCESS
}

init() {
    local f initqueue

    while (( $# )); do
        f=init_${1}
        [[ $(type -t $f) != function || "$initqueue" =~ (^| )"$f"( |$) ]] && break
        initqueue="$initqueue $f"
        shift
    done

    for f in $initqueue; do
       $f $@ || return $?
    done
}


# PROGRAM ----------------------------------------------------------------------
# export BASH_LOADABLES_PATH=$(pkg-config bash --variable=loadablesdir &2> /dev/null )
# [[ -n BASH_LOADABLES_PATH ]] && enable -f sleep sleep

init codes script config misc $@ && cmd_$(kv get script/command)
